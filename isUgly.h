//
//  isUgly.h
//  offer
//
//  Created by dudu294396112@qq.com on 2019/1/17.
//  Copyright © 2019年 wz_0818@163.com. All rights reserved.
//

#ifndef isUgly_h
#define isUgly_h

/*
 输入一个数，判断其是否为丑数
 只包含2.3.5三个因子的数即为丑数
 */
/*
 如果一个数被2.3.5连续整除，最后剩下1，则为丑叔
 如果剩下的因子不是1，则不是丑叔
 */

bool isUgly(int n)
{
    while (n%2==0)
        n>>1;
    while (n&3==0)
        n /= 3;
    while (n%5==0)
        n /= 5;
    
    return (n==1)? true:false;
}

/*
 输入一个数n，求从1开始的第n个丑数为多少，1为第一个丑数
 */

/*
 暴力算法，从1开始计算，算到第n个，即对1-n的每个数都要判断其是否为丑数，且其中大部分数不是丑数 -- 低效
 
 由丑数的性质，可知一个丑数肯定是其前面的某个丑数乘以2、3、5得来的
 可以维护一个数组，不断由前面的数得到新的丑数，直到第n个丑数
 实现过程中
 将数组中最大丑数计为M
 再从最开始将数组中数字都乘以2，小于M的数字必然已经在数组中，忽略，将大于M的加入数组即可，最后更新M
 乘以3
 乘以5
 直到第n个丑数
 
 该思路用O(n)的空间复杂度免去了判断每一个数字，只需求所有丑数
 */

#endif /* isUgly_h */
